import { createHTTPHandler } from '@trpc/server/adapters/standalone';
import http from 'http';
import fs from 'fs/promises';
import path from 'path';

import { appRouter } from '../trpc/root';
import { createTRPCContext } from '../trpc/trpc';
import { createViteServer } from './vite-utils';
import { serverEnv as env } from '../env';
import { execMiddlewares } from './middleware-utils';
import { serveBuild } from './custom-middlewares';
import { createCallerFactory } from '@trpc/server';
import { convertMetadataToHTML } from './metadata';
import { middlewareFactory } from '../middlewares';

const root = process.cwd();
const isProduction = env.NODE_ENV === 'production';
const BASE = env.BASE || '/';

// tRPC handler
const trpcHandler = createHTTPHandler({
  router: appRouter,
  createContext: (args) => createTRPCContext({ ...args, serverEnv: env }),
  batching: { enabled: true },
  onError: ({ error }) => console.error(`HTTP TRPC ERROR ${error.message}`),
});

// Vite server middleware only for development mode.
const viteDevServer = createViteServer({
  isProduction,
  root,
  base: BASE,
});

http
  .createServer((req, res) => {
    execMiddlewares(req, res, [...middlewareFactory], async (req, res) => {
      // All the paths matching /api/trpc/* are reserved for tRPC only.
      if (req.url?.startsWith('/api/trpc')) {
        req.url = req.url?.replace('/api/trpc', '');
        return trpcHandler(req, res);
      }

      // Creating trpc caller which will call the kyrixRouter from within server.
      const callerFactory = createCallerFactory()(appRouter);
      const trpcCaller = callerFactory({ req, res, env });

      // Getting the metadata and initial data per route.
      const data = await trpcCaller.kyrixRouter.ssr();

      // In development, we initialize a vite server, and allow it to handle everything
      // except sending of index.html.
      if (!isProduction) {
        const vite = await viteDevServer;
        if (!vite) throw new Error("Couldn't initialize vite development server");

        // Vite middleware will handle all the scripts and css assets in development mode.
        vite.middlewares(req, res, async () => {
          // Serving index.html for all the routes that vite cannot handle.
          try {
            const indexHTML = await fs.readFile(path.join(root, 'index.html'), {
              encoding: 'utf8',
            });

            // Modifying the HTML shell and injecting the meta and initial data.
            let modifiledIndexHTML: string | undefined;
            if (data) {
              const headHTML = convertMetadataToHTML(data.meta);
              modifiledIndexHTML = indexHTML.replace('<!-- app-meta -->', headHTML.trim()).replace(
                '<!-- app-context -->',
                `<script>window.__KYRIX_CONTEXT = ${JSON.stringify({
                  url: req.url ?? '/',
                  data: data.initialData,
                })}</script>`
              );
            }

            res.setHeader('Content-Type', 'text/html');
            res.end(modifiledIndexHTML);
          } catch (err) {
            console.error(err);

            // If failed to serve index.html, it'll be a fatal error.
            res.statusCode = 500;
            res.end(`Internal Server Error ${err}`);
            return;
          }
        });
      } else {
        // In Production, we serve the static files generated by vite like *.js, *.css,
        // from the dist/client directory but take care of the index.html ourselves.
        // We check the path for every request and try to match with any static files
        // in dist/client directory, if matches that file is sent else index.html is served.
        // This ensures the client-side router takes over after javascript loads.
        const serve = serveBuild({ root, isProduction, ssrData: data });
        return serve(req, res, () => {
          res.statusCode = 501;
          res.end('Not Implemented');
        });
      }
    });
  })
  .listen(env.SERVER_PORT, 'localhost', () => {
    console.log(`Server running on http://localhost:${env.SERVER_PORT}`);
  });
